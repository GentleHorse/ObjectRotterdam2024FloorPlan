{
  "version": 3,
  "sources": ["../../million/dist/packages/react.mjs", "../../million/dist/shared/million.8ff20917.mjs", "../../million/dist/shared/million.52d69b41.mjs", "../../million/dist/shared/million.4d88fdd9.mjs"],
  "sourcesContent": ["'use client';\nimport { useRef, useCallback, useMemo, createElement, Fragment, useState, useEffect, memo } from 'react';\nimport { b as block$1, q as queueMicrotask$, m as mount$, p as patch, a as arrayPatch$, c as mapArray, d as arrayMount$ } from '../shared/million.52d69b41.mjs';\nimport { a as MapHas$, c as MapSet$, b as MapGet$ } from '../shared/million.8ff20917.mjs';\nimport { u as unwrap, a as REGISTRY, p as processProps, E as Effect, S as SVG_RENDER_SCOPE, R as RENDER_SCOPE, r as renderReactScope } from '../shared/million.4d88fdd9.mjs';\nimport 'react-dom';\n\nconst block = (fn, { block: compiledBlock, shouldUpdate, svg, as } = {}) => {\n  const block2 = fn ? block$1(fn, unwrap, shouldUpdate, svg) : compiledBlock;\n  const defaultType = svg ? SVG_RENDER_SCOPE : RENDER_SCOPE;\n  const MillionBlock = (props, forwardedRef) => {\n    const hmrTimestamp = props._hmr;\n    const ref = useRef(null);\n    const patch$1 = useRef(null);\n    const portalRef = useRef([]);\n    props = processProps(props, forwardedRef, portalRef.current);\n    patch$1.current?.(props);\n    const effect = useCallback(() => {\n      if (!ref.current)\n        return;\n      const currentBlock = block2(props, props.key);\n      if (hmrTimestamp)\n        ref.current.textContent = \"\";\n      if (patch$1.current === null || hmrTimestamp) {\n        queueMicrotask$(() => {\n          mount$.call(currentBlock, ref.current, null);\n        });\n        patch$1.current = (props2) => {\n          queueMicrotask$(() => {\n            patch(currentBlock, block2(props2, props2.key, shouldUpdate));\n          });\n        };\n      }\n    }, []);\n    const marker = useMemo(() => {\n      return createElement(as ?? defaultType, { ref });\n    }, []);\n    const vnode = createElement(\n      Fragment,\n      null,\n      marker,\n      createElement(Effect, {\n        effect,\n        deps: hmrTimestamp ? [hmrTimestamp] : []\n      }),\n      ...portalRef.current.map((p) => p.portal)\n    );\n    return vnode;\n  };\n  if (!MapHas$.call(REGISTRY, MillionBlock)) {\n    MapSet$.call(REGISTRY, MillionBlock, block2);\n  }\n  return MillionBlock;\n};\n\nconst MillionArray = ({\n  each,\n  children,\n  memo: memo2,\n  svg,\n  as,\n  ...rest\n}) => {\n  const ref = useRef(null);\n  const [portals] = useState(() => ({\n    current: Array(each.length)\n  }));\n  const fragmentRef = useRef(null);\n  const cache = useRef({\n    each: null,\n    children: null,\n    mounted: false\n  });\n  const [, setMountPortals] = useState(false);\n  if (fragmentRef.current && (each !== cache.current.each || !memo2)) {\n    queueMicrotask$(() => {\n      const newChildren = createChildren(\n        each,\n        children,\n        cache,\n        portals,\n        memo2\n      );\n      arrayPatch$.call(fragmentRef.current, mapArray(newChildren));\n    });\n  }\n  const defaultType = svg ? SVG_RENDER_SCOPE : RENDER_SCOPE;\n  const MillionFor = createElement(\n    Fragment,\n    null,\n    createElement(as ?? defaultType, { ...rest, ref }),\n    ...portals.current.map((p) => p.portal)\n  );\n  useEffect(() => {\n    if (!ref.current || fragmentRef.current)\n      return;\n    queueMicrotask$(() => {\n      if (cache.current.mounted)\n        return;\n      const newChildren = createChildren(\n        each,\n        children,\n        cache,\n        portals,\n        memo2\n      );\n      fragmentRef.current = mapArray(newChildren);\n      if (!MapHas$.call(REGISTRY, MillionFor)) {\n        MapSet$.call(REGISTRY, MillionFor, fragmentRef.current);\n      }\n      arrayMount$.call(fragmentRef.current, ref.current);\n      cache.current.mounted = true;\n      setMountPortals(true);\n    });\n  }, [ref.current]);\n  return MillionFor;\n};\nconst typedMemo = memo;\nconst For = typedMemo(MillionArray);\nconst createChildren = (each, getComponent, cache, portals, memo2) => {\n  const children = Array(each.length);\n  const currentCache = cache.current;\n  for (let i = 0, l = each.length; i < l; ++i) {\n    if (memo2 && currentCache.each && currentCache.each[i] === each[i]) {\n      children[i] = currentCache.children?.[i];\n      continue;\n    }\n    const vnode = getComponent(each[i], i);\n    if (MapHas$.call(REGISTRY, vnode.type)) {\n      if (!currentCache.block) {\n        currentCache.block = MapGet$.call(REGISTRY, vnode.type);\n      }\n      children[i] = currentCache.block(vnode.props, i);\n      continue;\n    }\n    if (typeof vnode.type === \"function\" && \"__block_callable__\" in vnode.type) {\n      const puppetComponent = vnode.type(vnode.props);\n      if (MapHas$.call(REGISTRY, puppetComponent.type)) {\n        const puppetBlock = MapGet$.call(REGISTRY, puppetComponent.type);\n        if (typeof puppetBlock === \"function\") {\n          children[i] = puppetBlock(puppetComponent.props);\n          continue;\n        }\n      }\n    }\n    const block = block$1((props) => props?.scope);\n    const currentBlock = (props, index) => {\n      return block(\n        {\n          scope: renderReactScope(\n            createElement(vnode.type, props),\n            false,\n            portals.current,\n            index,\n            false\n          )\n        },\n        vnode.key ? String(vnode.key) : void 0\n      );\n    };\n    MapSet$.call(REGISTRY, vnode.type, currentBlock);\n    currentCache.block = currentBlock;\n    children[i] = currentBlock(vnode.props, i);\n  }\n  currentCache.each = each;\n  currentCache.children = children;\n  return children;\n};\n\nconst shutUpReact = () => {\n  const consoleOverride = (callback) => (message, ...rest) => {\n    if (message.startsWith(\"Warning:\") || message.startsWith(\"Invalid hook call.\"))\n      return;\n    callback(message, rest);\n  };\n  console.warn = consoleOverride(console.warn);\n  console.error = consoleOverride(console.error);\n};\n\nconst macro = (expression) => expression;\n\nexport { For, REGISTRY, block, macro, renderReactScope, shutUpReact, unwrap };\n", "'use client';\nconst Object$ = Object;\nconst Map$ = Map;\nconst Set$ = Set;\nconst SetHas$ = Set$.prototype.has;\nconst SetAdd$ = Set$.prototype.add;\nconst MapHas$ = Map$.prototype.has;\nconst MapGet$ = Map$.prototype.get;\nconst MapSet$ = Map$.prototype.set;\nconst ChildFlag = 1;\nconst AttributeFlag = 2;\nconst EventFlag = 4;\nconst StyleAttributeFlag = 8;\nconst SvgAttributeFlag = 16;\nconst BlockFlag = 32;\nconst TEXT_NODE_CACHE = \"__t\";\nconst EVENT_PATCH = \"__p\";\nconst EVENTS_REGISTRY = \"__e\";\nconst IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\nconst XLINK_NS = \"http://www.w3.org/1999/xlink\";\nconst XML_NS = \"http://www.w3.org/2000/xmlns/\";\nconst X_CHAR = 120;\nconst NON_PROPS = new Set$([\"href\", \"list\", \"form\", \"tabIndex\", \"download\"]);\nconst VOID_ELEMENTS = new Set$([\"area\", \"base\", \"basefont\", \"bgsound\", \"br\", \"col\", \"command\", \"embed\", \"frame\", \"hr\", \"image\", \"img\", \"input\", \"isindex\", \"keygen\", \"link\", \"menuitem\", \"meta\", \"nextid\", \"param\", \"source\", \"track\", \"wbr\"]);\n\nexport { AttributeFlag as A, BlockFlag as B, ChildFlag as C, EventFlag as E, IS_NON_DIMENSIONAL as I, Map$ as M, NON_PROPS as N, Object$ as O, StyleAttributeFlag as S, TEXT_NODE_CACHE as T, VOID_ELEMENTS as V, X_CHAR as X, MapHas$ as a, MapGet$ as b, MapSet$ as c, SvgAttributeFlag as d, EVENTS_REGISTRY as e, Set$ as f, SetHas$ as g, SetAdd$ as h, XML_NS as i, XLINK_NS as j, EVENT_PATCH as k };\n", "'use client';\nimport { e as EVENTS_REGISTRY, f as Set$, O as Object$, g as SetHas$, h as SetAdd$, I as IS_NON_DIMENSIONAL, i as XML_NS, j as XLINK_NS, N as NON_PROPS, C as ChildFlag, E as EventFlag, S as StyleAttributeFlag, X as X_CHAR, d as SvgAttributeFlag, A as AttributeFlag, V as VOID_ELEMENTS, B as BlockFlag, M as Map$, c as MapSet$, T as TEXT_NODE_CACHE, k as EVENT_PATCH } from './million.8ff20917.mjs';\n\nif (typeof window === \"undefined\") {\n  throw new Error(\n    \"See http://million.dev/docs/install to install the compiler.\"\n  );\n}\nconst document$ = document;\nconst queueMicrotask$ = queueMicrotask;\ndocument$.createElement(\"template\");\nconst HTM_TEMPLATE = /* @__PURE__ */ document$.createElement(\"template\");\nconst HTM_TEMPLATE_CONTENT = HTM_TEMPLATE.content;\nconst SVG_TEMPLATE = /* @__PURE__ */ document$.createElementNS(\n  \"http://www.w3.org/2000/svg\",\n  \"svg\"\n);\nconst node$ = Node.prototype;\nconst element$ = Element.prototype;\nconst characterData$ = CharacterData.prototype;\nconst getOwnPropertyDescriptor$ = Object$.getOwnPropertyDescriptor;\nconst insertBefore$ = node$.insertBefore;\nconst cloneNode$ = node$.cloneNode;\nconst replaceChild$ = node$.replaceChild;\nconst remove$$1 = element$.remove;\nconst addEventListener$ = node$.addEventListener;\nconst removeAttribute$ = element$.removeAttribute;\nconst setAttribute$ = element$.setAttribute;\nconst setAttributeNS$ = element$.setAttributeNS;\nconst setTextContent$ = getOwnPropertyDescriptor$(node$, \"textContent\").set;\nconst firstChild$ = getOwnPropertyDescriptor$(node$, \"firstChild\").get;\nconst nextSibling$ = getOwnPropertyDescriptor$(node$, \"nextSibling\").get;\nconst characterDataSet$ = getOwnPropertyDescriptor$(\n  characterData$,\n  \"data\"\n).set;\nconst stringToDOM = (content, svg) => {\n  const template = svg ? SVG_TEMPLATE : HTM_TEMPLATE;\n  template.innerHTML = content;\n  const dom = svg ? SVG_TEMPLATE : HTM_TEMPLATE_CONTENT;\n  return dom.firstChild;\n};\ndocument$[EVENTS_REGISTRY] = new Set$();\nconst createEventListener = (el, name, value) => {\n  let event = name.toLowerCase();\n  let capture = false;\n  if (event.endsWith(\"capture\")) {\n    event = event.slice(0, -7);\n    capture = true;\n  }\n  const key = `$$${event}`;\n  if (!SetHas$.call(document$[EVENTS_REGISTRY], event)) {\n    addEventListener$.call(\n      document$,\n      event,\n      (nativeEvent) => {\n        let el2 = nativeEvent.target;\n        while (el2) {\n          const handler = el2[key];\n          if (handler) {\n            Object$.defineProperty(nativeEvent, \"currentTarget\", {\n              configurable: true,\n              get() {\n                return el2;\n              }\n            });\n            handler(nativeEvent);\n          }\n          el2 = el2.parentNode;\n        }\n      },\n      { capture }\n    );\n    SetAdd$.call(document$[EVENTS_REGISTRY], event);\n  }\n  const patch = (newValue) => {\n    if (!newValue) {\n      el[key] = null;\n    } else if (!(\"key\" in newValue && newValue.key === el[key]?.key)) {\n      el[key] = newValue;\n    }\n  };\n  patch(value);\n  return patch;\n};\nconst childAt = (el, index) => {\n  let child = firstChild$.call(el);\n  if (index) {\n    for (let j = 0; j < index; ++j) {\n      if (!child)\n        break;\n      child = nextSibling$.call(child);\n    }\n  }\n  return child;\n};\nconst insertText = (el, value, index) => {\n  const node = document$.createTextNode(value);\n  const child = childAt(el, index);\n  insertBefore$.call(el, node, child);\n  return node;\n};\nconst setText = (el, value) => {\n  characterDataSet$.call(el, value);\n};\nconst setStyleAttribute = (el, name, value) => {\n  if (typeof value !== \"number\" || IS_NON_DIMENSIONAL.test(name)) {\n    el.style[name] = value;\n  } else if (typeof value === \"string\") {\n    el.style.cssText = value;\n  } else if (name.startsWith(\"-\")) {\n    el.style.setProperty(name, String(value));\n  } else if (value === void 0 || value === null) {\n    el.style[name] = \"\";\n  } else {\n    el.style[name] = `${String(value)}px`;\n  }\n};\nconst setSvgAttribute = (el, name, value) => {\n  name = name.replace(/xlink(?:H|:h)/, \"h\").replace(/sName$/, \"s\");\n  if (name.startsWith(\"xmlns\")) {\n    setAttributeNS$.call(el, XML_NS, name, String(value));\n  } else if (name.startsWith(\"xlink\")) {\n    setAttributeNS$.call(el, XLINK_NS, \"href\", String(value));\n  }\n};\nconst setAttribute = (el, name, value) => {\n  const isValueNully = value === void 0 || value === null;\n  value = isValueNully ? \"\" : value;\n  if (name in el && el[name] !== void 0 && el[name] !== null && !(el instanceof SVGElement) && SetHas$.call(NON_PROPS, name)) {\n    try {\n      el[name] = value;\n    } catch (_err) {\n    }\n  } else if (!isValueNully && value !== \"\" && (value !== false || name.includes(\"-\"))) {\n    setAttribute$.call(el, name, String(value));\n  } else {\n    removeAttribute$.call(el, name);\n  }\n};\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass AbstractBlock {\n  constructor() {\n    /* root */\n    __publicField$1(this, \"r\");\n    /* edits */\n    __publicField$1(this, \"e\");\n    /* el */\n    __publicField$1(this, \"l\");\n    /* getElements */\n    __publicField$1(this, \"g\");\n    /* _parent */\n    __publicField$1(this, \"_t\");\n    /* props */\n    __publicField$1(this, \"d\");\n    /* key */\n    __publicField$1(this, \"k\");\n    /* cache */\n    __publicField$1(this, \"c\");\n  }\n}\n\nconst renderToTemplate = (vnode, edits = [], path = []) => {\n  if (typeof vnode === \"string\")\n    return vnode;\n  if (typeof vnode === \"number\" || typeof vnode === \"bigint\" || vnode === true) {\n    return String(vnode);\n  }\n  if (vnode === null || vnode === void 0 || vnode === false)\n    return \"\";\n  if (typeof vnode === \"object\" && \"$\" in vnode) {\n    edits.push({\n      p: path,\n      e: [\n        {\n          /* type */\n          t: ChildFlag,\n          /* name */\n          n: null,\n          /* value */\n          v: null,\n          /* hole */\n          h: vnode.$,\n          /* index */\n          i: 0,\n          /* listener */\n          l: null,\n          /* patch */\n          p: null,\n          /* block */\n          b: null\n        }\n      ],\n      i: []\n    });\n    return \"<slot/>\";\n  }\n  let props = \"\";\n  let children = \"\";\n  const current = {\n    p: path,\n    // The location of the edit in in the virtual node tree\n    e: [],\n    // Occur on mount + patch\n    i: []\n    // Occur before mount\n  };\n  for (let name in vnode.props) {\n    const value = vnode.props[name];\n    if (name === \"key\" || name === \"ref\" || name === \"children\") {\n      continue;\n    }\n    if (name === \"className\")\n      name = \"class\";\n    if (name === \"htmlFor\")\n      name = \"for\";\n    if (name.startsWith(\"on\")) {\n      const isValueHole = \"$\" in value;\n      if (isValueHole) {\n        current.e.push({\n          /* type */\n          t: EventFlag,\n          /* name */\n          n: name.slice(2),\n          /* value */\n          v: null,\n          /* hole */\n          h: value.$,\n          /* index */\n          i: null,\n          /* listener */\n          l: null,\n          /* patch */\n          p: null,\n          /* block */\n          b: null\n        });\n      } else {\n        current.i.push({\n          /* type */\n          t: EventFlag,\n          /* name */\n          n: name.slice(2),\n          /* value */\n          v: null,\n          /* hole */\n          h: null,\n          /* index */\n          i: null,\n          /* listener */\n          l: value,\n          /* patch */\n          p: null,\n          /* block */\n          b: null\n        });\n      }\n      continue;\n    }\n    if (value) {\n      if (typeof value === \"object\" && \"$\" in value) {\n        if (name === \"style\") {\n          current.e.push({\n            /* type */\n            t: StyleAttributeFlag,\n            /* name */\n            n: name,\n            /* value */\n            v: null,\n            /* hole */\n            h: value.$,\n            /* index */\n            i: null,\n            /* listener */\n            l: null,\n            /* patch */\n            p: null,\n            /* block */\n            b: null\n          });\n        } else if (name.charCodeAt(0) === X_CHAR) {\n          current.e.push({\n            /* type */\n            t: SvgAttributeFlag,\n            /* name */\n            n: name,\n            /* value */\n            v: null,\n            /* hole */\n            h: value.$,\n            /* index */\n            i: null,\n            /* listener */\n            l: null,\n            /* patch */\n            p: null,\n            /* block */\n            b: null\n          });\n        } else {\n          current.e.push({\n            /* type */\n            t: AttributeFlag,\n            /* name */\n            n: name,\n            /* value */\n            v: null,\n            /* hole */\n            h: value.$,\n            /* index */\n            i: null,\n            /* listener */\n            l: null,\n            /* patch */\n            p: null,\n            /* block */\n            b: null\n          });\n        }\n        continue;\n      }\n      if (name === \"style\" && typeof value === \"object\") {\n        let style = \"\";\n        for (const key in value) {\n          if (typeof value[key] === \"object\") {\n            current.e.push({\n              /* type */\n              t: StyleAttributeFlag,\n              /* name */\n              n: key,\n              /* value */\n              v: null,\n              /* hole */\n              h: value[key].$,\n              /* index */\n              i: null,\n              /* listener */\n              l: null,\n              /* patch */\n              p: null,\n              /* block */\n              b: null\n            });\n            continue;\n          }\n          let kebabKey = \"\";\n          for (let i = 0, j = key.length; i < j; ++i) {\n            const char = key.charCodeAt(i);\n            if (char < 97) {\n              kebabKey += `-${String.fromCharCode(char + 32)}`;\n            } else {\n              kebabKey += key[i];\n            }\n          }\n          style += `${kebabKey}:${String(value[key])};`;\n        }\n        props += ` style=\"${style}\"`;\n        continue;\n      }\n      props += ` ${name}=\"${String(value)}\"`;\n    }\n  }\n  if (SetHas$.call(VOID_ELEMENTS, vnode.type)) {\n    if (current.e.length)\n      edits.push(current);\n    return `<${vnode.type}${props} />`;\n  }\n  let canMergeString = false;\n  for (let i = 0, j = vnode.props.children?.length || 0, k = 0; i < j; ++i) {\n    const child = vnode.props.children?.[i];\n    if (child === null || child === void 0 || child === false)\n      continue;\n    if (typeof child === \"object\" && \"$\" in child) {\n      current.e.push({\n        /* type */\n        t: ChildFlag,\n        /* name */\n        n: null,\n        /* value */\n        v: null,\n        /* hole */\n        h: child.$,\n        /* index */\n        i,\n        /* listener */\n        l: null,\n        /* patch */\n        p: null,\n        /* block */\n        b: null\n      });\n      continue;\n    }\n    if (child instanceof AbstractBlock) {\n      current.i.push({\n        /* type */\n        t: BlockFlag,\n        /* name */\n        n: null,\n        /* value */\n        v: null,\n        /* hole */\n        h: null,\n        /* index */\n        i,\n        /* listener */\n        l: null,\n        /* patch */\n        p: null,\n        /* block */\n        b: child\n      });\n      continue;\n    }\n    if (typeof child === \"string\" || typeof child === \"number\" || typeof child === \"bigint\") {\n      const value = typeof child === \"number\" || typeof child === \"bigint\" ? String(child) : child;\n      if (canMergeString) {\n        current.i.push({\n          /* type */\n          t: ChildFlag,\n          /* name */\n          n: null,\n          /* value */\n          v: value,\n          /* hole */\n          h: null,\n          /* index */\n          i,\n          /* listener */\n          l: null,\n          /* patch */\n          p: null,\n          /* block */\n          b: null\n        });\n        continue;\n      }\n      canMergeString = true;\n      children += value;\n      k++;\n      continue;\n    }\n    canMergeString = false;\n    const newPath = path.slice();\n    newPath.push(k++);\n    children += renderToTemplate(child, edits, newPath);\n  }\n  if (current.i.length || current.e.length)\n    edits.push(current);\n  return `<${vnode.type}${props}>${children}</${vnode.type}>`;\n};\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst mapArray = (children) => {\n  return new ArrayBlock(children);\n};\nclass ArrayBlock extends AbstractBlock {\n  constructor(children) {\n    super();\n    __publicField(this, \"b\");\n    this.b = children;\n  }\n  v() {\n  }\n  p(fragment) {\n    const oldChildren = this.b;\n    const newChildren = fragment.b;\n    const oldChildrenLength = oldChildren.length;\n    const newChildrenLength = newChildren.length;\n    const parent = this.t();\n    if (this === fragment)\n      return parent;\n    if (newChildrenLength === 0 && oldChildrenLength === 0)\n      return parent;\n    this.b = newChildren;\n    if (newChildrenLength === 0) {\n      arrayRemove$.call(this);\n      return parent;\n    }\n    if (oldChildrenLength === 0) {\n      arrayMount$.call(fragment, parent);\n      return parent;\n    }\n    let oldHead = 0;\n    let newHead = 0;\n    let oldTail = oldChildrenLength - 1;\n    let newTail = newChildrenLength - 1;\n    let oldHeadChild = oldChildren[0];\n    let newHeadChild = newChildren[0];\n    let oldTailChild = oldChildren[oldTail];\n    let newTailChild = newChildren[newTail];\n    let oldKeyMap;\n    while (oldHead <= oldTail && newHead <= newTail) {\n      if (!oldHeadChild) {\n        oldHeadChild = oldChildren[++oldHead];\n        continue;\n      }\n      if (!oldTailChild) {\n        oldTailChild = oldChildren[--oldTail];\n        continue;\n      }\n      const oldHeadKey = oldHeadChild.k;\n      const newHeadKey = newHeadChild.k;\n      if (oldHeadKey === newHeadKey) {\n        patch$.call(oldHeadChild, newHeadChild);\n        newChildren[newHead] = oldHeadChild;\n        oldHeadChild = oldChildren[++oldHead];\n        newHeadChild = newChildren[++newHead];\n        continue;\n      }\n      const oldTailKey = oldTailChild.k;\n      const newTailKey = newTailChild.k;\n      if (oldTailKey === newTailKey) {\n        patch$.call(oldTailChild, newTailChild);\n        newChildren[newTail] = oldTailChild;\n        oldTailChild = oldChildren[--oldTail];\n        newTailChild = newChildren[--newTail];\n        continue;\n      }\n      if (oldHeadKey === newTailKey) {\n        patch$.call(oldHeadChild, newTailChild);\n        newChildren[newTail] = oldHeadChild;\n        const nextChild = newChildren[newTail + 1];\n        move$.call(oldHeadChild, nextChild, nextChild?.l || null);\n        oldHeadChild = oldChildren[++oldHead];\n        newTailChild = newChildren[--newTail];\n        continue;\n      }\n      if (oldTailKey === newHeadKey) {\n        patch$.call(oldTailChild, newHeadChild);\n        newChildren[newHead] = oldTailChild;\n        const nextChild = oldChildren[oldHead];\n        move$.call(oldTailChild, nextChild, nextChild?.l || null);\n        oldTailChild = oldChildren[--oldTail];\n        newHeadChild = newChildren[++newHead];\n        continue;\n      }\n      if (!oldKeyMap) {\n        oldKeyMap = new Map$();\n        for (let i = oldHead; i <= oldTail; i++) {\n          MapSet$.call(oldKeyMap, oldChildren[i].k, i);\n        }\n      }\n      const oldIndex = oldKeyMap.get(newHeadKey);\n      if (oldIndex === void 0) {\n        mount$.call(newHeadChild, parent, oldHeadChild.l || null);\n      } else {\n        const oldChild = oldChildren[oldIndex];\n        move$.call(oldChild, oldHeadChild, null);\n        patch$.call(oldChild, newHeadChild);\n        newChildren[newHead] = oldChild;\n        oldChildren[oldIndex] = null;\n      }\n      newHeadChild = newChildren[++newHead];\n    }\n    if (oldHead <= oldTail || newHead <= newTail) {\n      if (oldHead > oldTail) {\n        const nextChild = newChildren[newTail + 1];\n        for (let i = newHead; i <= newTail; ++i) {\n          mount$.call(newChildren[i], parent, nextChild ? nextChild.l : null);\n        }\n      } else {\n        for (let i = oldHead; i <= oldTail; ++i) {\n          remove$.call(oldChildren[i]);\n        }\n      }\n    }\n    return parent;\n  }\n  m(parent, refNode = null) {\n    if (this._t)\n      return this._t;\n    for (let i = 0, j = this.b.length; i < j; ++i) {\n      const block = this.b[i];\n      mount$.call(block, parent, refNode);\n    }\n    this._t = parent;\n    return parent;\n  }\n  x() {\n    const parent = this.t();\n    if (parent) {\n      setTextContent$.call(parent, \"\");\n    } else {\n      for (let i = 0, j = this.b.length; i < j; ++i) {\n        remove$.call(this.b[i]);\n      }\n    }\n    this.b = [];\n  }\n  u() {\n    return true;\n  }\n  s() {\n    return this.b.map((block) => block.s()).join(\"\");\n  }\n  t() {\n    if (!this._t)\n      this._t = this.b[0].t();\n    return this._t;\n  }\n}\nconst array$ = ArrayBlock.prototype;\nconst arrayMount$ = array$.m;\nconst arrayPatch$ = array$.p;\nconst arrayRemove$ = array$.x;\n\nconst HOLE_PROXY = new Proxy(\n  {},\n  {\n    // A universal getter will return a Hole instance if props[any] is accessed\n    // Allows code to identify holes in virtual nodes (\"digs\" them out)\n    get(_, key) {\n      return { $: key };\n    }\n  }\n);\nconst block = (fn, unwrap, shouldUpdate, svg) => {\n  const vnode = fn(HOLE_PROXY);\n  const edits = [];\n  const root = stringToDOM(\n    renderToTemplate(unwrap ? unwrap(vnode) : vnode, edits),\n    svg\n  );\n  return (props, key, shouldUpdateCurrentBlock) => {\n    return new Block(\n      root,\n      edits,\n      props,\n      key ?? props?.key ?? null,\n      shouldUpdateCurrentBlock ?? shouldUpdate ?? null,\n      null\n    );\n  };\n};\nconst mount = (block2, parent) => {\n  if (\"b\" in block2 && parent) {\n    return arrayMount$.call(block2, parent);\n  }\n  return mount$.call(block2, parent);\n};\nconst patch = (oldBlock, newBlock) => {\n  if (\"b\" in oldBlock || \"b\" in newBlock) {\n    arrayPatch$.call(oldBlock, newBlock);\n  }\n  if (!oldBlock.l)\n    mount$.call(oldBlock);\n  if (oldBlock.k && oldBlock.k === newBlock.k || oldBlock.r === newBlock.r) {\n    return patch$.call(oldBlock, newBlock);\n  }\n  const el = mount$.call(newBlock, oldBlock.t(), oldBlock.l);\n  remove$.call(oldBlock);\n  oldBlock.k = newBlock.k;\n  return el;\n};\nclass Block extends AbstractBlock {\n  constructor(root, edits, props, key, shouldUpdate, getElements) {\n    super();\n    this.r = root;\n    this.d = props;\n    this.e = edits;\n    this.k = key;\n    this.c = Array(edits.length);\n    if (shouldUpdate)\n      this.u = shouldUpdate;\n    if (getElements)\n      this.g = getElements;\n  }\n  m(parent, refNode = null) {\n    if (this.l)\n      return this.l;\n    const root = cloneNode$.call(this.r, true);\n    const elements = this.g?.(root);\n    if (elements)\n      this.c = elements;\n    for (let i = 0, j = this.e.length; i < j; ++i) {\n      const current = this.e[i];\n      const el = elements?.[i] ?? getCurrentElement(current.p, root, this.c, i);\n      for (let k = 0, l = current.e.length; k < l; ++k) {\n        const edit = current.e[k];\n        const value = this.d[edit.h];\n        if (edit.t & ChildFlag) {\n          if (value instanceof AbstractBlock) {\n            value.m(el, childAt(el, edit.i));\n            continue;\n          }\n          if (!el[TEXT_NODE_CACHE])\n            el[TEXT_NODE_CACHE] = new Array(l);\n          if (value && typeof value === \"object\" && \"foreign\" in value) {\n            const scopeEl = value.current;\n            el[TEXT_NODE_CACHE][k] = scopeEl;\n            insertBefore$.call(el, scopeEl, childAt(el, edit.i));\n            continue;\n          }\n          el[TEXT_NODE_CACHE][k] = insertText(\n            el,\n            // eslint-disable-next-line eqeqeq\n            value == null || value === false ? \"\" : String(value),\n            edit.i\n          );\n        } else if (edit.t & EventFlag) {\n          const patch2 = createEventListener(el, edit.n, value);\n          el[EVENT_PATCH + edit.n] = patch2;\n        } else if (edit.t & AttributeFlag) {\n          setAttribute(el, edit.n, value);\n        } else if (edit.t & StyleAttributeFlag) {\n          if (typeof value === \"string\" || typeof value === \"number\") {\n            setStyleAttribute(el, edit.n, value);\n          } else {\n            for (const style in value) {\n              setStyleAttribute(el, style, value[style]);\n            }\n          }\n        } else {\n          setSvgAttribute(el, edit.n, value);\n        }\n      }\n      const initsLength = current.i?.length;\n      if (!initsLength)\n        continue;\n      for (let k = 0; k < initsLength; ++k) {\n        const init = current.i[k];\n        if (init.t & ChildFlag) {\n          if (init.v)\n            insertText(el, init.v, init.i);\n        } else if (init.t & EventFlag) {\n          createEventListener(el, init.n, init.l);\n        } else {\n          init.b.m(el, childAt(el, init.i));\n        }\n      }\n    }\n    if (parent) {\n      insertBefore$.call(parent, root, refNode);\n    }\n    this.l = root;\n    return root;\n  }\n  p(newBlock) {\n    const root = this.l;\n    if (!newBlock.d)\n      return root;\n    const props = this.d;\n    if (!shouldUpdate$.call(this, props, newBlock.d))\n      return root;\n    this.d = newBlock.d;\n    for (let i = 0, j = this.e.length; i < j; ++i) {\n      const current = this.e[i];\n      const el = this.c[i] ?? getCurrentElement(current.p, root, this.c, i);\n      for (let k = 0, l = current.e.length; k < l; ++k) {\n        const edit = current.e[k];\n        const oldValue = props[edit.h];\n        const newValue = newBlock.d[edit.h];\n        if (newValue === oldValue)\n          continue;\n        if (edit.t & EventFlag) {\n          el[EVENT_PATCH + edit.n](newValue);\n          continue;\n        }\n        if (edit.t & ChildFlag) {\n          if (oldValue instanceof AbstractBlock) {\n            const firstEdit = newBlock.e?.[i]?.e[k];\n            const newChildBlock = newBlock.d[firstEdit.h];\n            oldValue.p(newChildBlock);\n            continue;\n          }\n          if (newValue && typeof newValue === \"object\" && \"foreign\" in newValue) {\n            const scopeEl = el[TEXT_NODE_CACHE][k];\n            if (\"unstable\" in newValue && oldValue !== newValue) {\n              const newScopeEl = newValue.current;\n              el[TEXT_NODE_CACHE][k] = newScopeEl;\n              replaceChild$.call(el, newScopeEl, scopeEl);\n            } else {\n              newValue.current = scopeEl;\n            }\n            continue;\n          }\n          setText(\n            el[TEXT_NODE_CACHE][k],\n            // eslint-disable-next-line eqeqeq\n            newValue == null || newValue === false ? \"\" : String(newValue)\n          );\n        } else if (edit.t & AttributeFlag) {\n          setAttribute(el, edit.n, newValue);\n        } else if (edit.t & StyleAttributeFlag) {\n          if (typeof newValue === \"string\" || typeof newValue === \"number\") {\n            setStyleAttribute(el, edit.n, newValue);\n          } else {\n            for (const style in newValue) {\n              if (newValue[style] !== oldValue[style]) {\n                setStyleAttribute(el, style, newValue[style]);\n              }\n            }\n          }\n        } else {\n          setSvgAttribute(el, edit.n, newValue);\n        }\n      }\n    }\n    return root;\n  }\n  v(block2 = null, refNode = null) {\n    insertBefore$.call(this.t(), this.l, block2 ? block2.l : refNode);\n  }\n  x() {\n    remove$$1.call(this.l);\n    this.l = null;\n  }\n  u(_oldProps, _newProps) {\n    return true;\n  }\n  s() {\n    return String(this.l?.outerHTML);\n  }\n  t() {\n    if (!this._t)\n      this._t = this.l?.parentElement;\n    return this._t;\n  }\n}\nconst getCurrentElement = (path, root, cache, key) => {\n  const pathLength = path.length;\n  if (!pathLength)\n    return root;\n  const isCacheAndKeyExists = cache && key !== void 0;\n  if (isCacheAndKeyExists && cache[key]) {\n    return cache[key];\n  }\n  for (let i = 0; i < pathLength; ++i) {\n    const siblings = path[i];\n    root = childAt(root, siblings);\n  }\n  if (isCacheAndKeyExists)\n    cache[key] = root;\n  return root;\n};\nconst withKey = (value, key) => {\n  value.key = key;\n  return value;\n};\nconst block$ = Block.prototype;\nconst mount$ = block$.m;\nconst patch$ = block$.p;\nconst move$ = block$.v;\nconst remove$ = block$.x;\nconst shouldUpdate$ = block$.u;\n\nexport { ArrayBlock as A, Block as B, arrayPatch$ as a, block as b, mapArray as c, arrayMount$ as d, mount as e, AbstractBlock as f, firstChild$ as g, mount$ as m, nextSibling$ as n, patch as p, queueMicrotask$ as q, renderToTemplate as r, stringToDOM as s, withKey as w };\n", "'use client';\nimport { useEffect, createElement, isValidElement, Fragment } from 'react';\nimport { createPortal } from 'react-dom';\n\nconst RENDER_SCOPE = \"slot\";\nconst SVG_RENDER_SCOPE = \"g\";\nconst Effect = ({\n  effect,\n  deps\n}) => {\n  useEffect(effect, deps || []);\n  return null;\n};\nconst REGISTRY = /* @__PURE__ */ new Map();\n\nconst processProps = (props, ref, portals) => {\n  const processedProps = { ref };\n  let currentIndex = 0;\n  for (const key in props) {\n    const value = props[key];\n    if (isValidElement(value)) {\n      processedProps[key] = renderReactScope(\n        value,\n        false,\n        portals,\n        currentIndex++,\n        false\n      );\n      continue;\n    }\n    processedProps[key] = props[key];\n  }\n  return processedProps;\n};\nconst renderReactScope = (vnode, unstable, portals, currentIndex, server) => {\n  const el = portals?.[currentIndex]?.current;\n  if (typeof window === \"undefined\" || server && !el) {\n    return createElement(\n      RENDER_SCOPE,\n      { suppressHydrationWarning: true },\n      vnode\n    );\n  }\n  if (isValidElement(vnode) && typeof vnode.type === \"function\" && \"__block_callable__\" in vnode.type) {\n    const puppetComponent = vnode.type(vnode.props);\n    if (REGISTRY.has(puppetComponent.type)) {\n      const puppetBlock = REGISTRY.get(puppetComponent.type);\n      if (typeof puppetBlock === \"function\") {\n        return puppetBlock(puppetComponent.props);\n      }\n    }\n  }\n  const current = el ?? document.createElement(RENDER_SCOPE);\n  const reactPortal = createPortal(vnode, current);\n  const millionPortal = {\n    foreign: true,\n    current,\n    portal: reactPortal,\n    unstable\n  };\n  if (portals)\n    portals[currentIndex] = millionPortal;\n  return millionPortal;\n};\nconst unwrap = (vnode) => {\n  if (typeof vnode !== \"object\" || vnode === null || !(\"type\" in vnode)) {\n    if (typeof vnode === \"number\") {\n      return String(vnode);\n    }\n    return vnode;\n  }\n  let type = vnode.type;\n  if (typeof type === \"function\") {\n    return unwrap(type(vnode.props ?? {}));\n  }\n  if (typeof type === \"object\" && \"$\" in type)\n    return type;\n  const props = { ...vnode.props };\n  if (\"css\" in props && \"__EMOTION_TYPE_PLEASE_DO_NOT_USE__\" in props) {\n    props.style = props.css.styles;\n    type = props.__EMOTION_TYPE_PLEASE_DO_NOT_USE__;\n    delete props.__EMOTION_TYPE_PLEASE_DO_NOT_USE__;\n    delete props.css;\n  }\n  const children = vnode.props?.children;\n  if (children !== void 0 && children !== null) {\n    props.children = flatten(vnode.props.children).map(\n      (child) => unwrap(child)\n    );\n  }\n  return {\n    type,\n    // lets pretend no function go through\n    props\n  };\n};\nconst flatten = (rawChildren) => {\n  if (rawChildren === void 0 || rawChildren === null)\n    return [];\n  if (typeof rawChildren === \"object\" && \"type\" in rawChildren && rawChildren.type === Fragment) {\n    return flatten(rawChildren.props.children);\n  }\n  if (!Array.isArray(rawChildren) || typeof rawChildren === \"object\" && \"$\" in rawChildren) {\n    return [rawChildren];\n  }\n  const flattenedChildren = rawChildren.flat(Infinity);\n  const children = [];\n  for (let i = 0, l = flattenedChildren.length; i < l; ++i) {\n    children.push(...flatten(flattenedChildren[i]));\n  }\n  return children;\n};\n\nexport { Effect as E, RENDER_SCOPE as R, SVG_RENDER_SCOPE as S, REGISTRY as a, processProps as p, renderReactScope as r, unwrap as u };\n"],
  "mappings": "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",
  "names": ["import_react", "patch", "block", "unwrap", "block2", "import_react_dom", "block", "block2"]
}
